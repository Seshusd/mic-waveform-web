<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mic Waveform · Web 实时波形/频谱</title>
  <style>
    :root {
      --bg: #0b0e11;
      --panel: #12161a;
      --text: #dfe6ee;
      --muted: #8894a3;
      --accent: #8ab4ff;
      --grid: #22303c;
      --border: #1b2229;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, PingFang SC, Noto Sans SC, "Microsoft YaHei", sans-serif;
    }
    header {
      padding: 16px 20px; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; gap: 14px; flex-wrap: wrap;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
    }
    h1 { font-size: 18px; margin: 0; font-weight: 600; letter-spacing: .2px; }
    .tag { color: var(--muted); font-size: 12px; }
    .spacer { flex: 1; }
    .ctrl {
      display: inline-flex; align-items: center; gap: 8px; background: var(--panel);
      border: 1px solid var(--border); padding: 8px 10px; border-radius: 12px;
    }
    select, button {
      background: #0e1318; color: var(--text); border: 1px solid var(--border);
      padding: 8px 10px; border-radius: 10px; font-size: 14px;
    }
    button { cursor: pointer; }
    button[disabled] { opacity: .6; cursor: not-allowed; }

    main { padding: 16px; display: grid; gap: 16px; grid-template-columns: 1fr; }
    .card {
      background: var(--panel); border: 1px solid var(--border); border-radius: 16px;
      padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2 { margin: 6px 6px 10px; font-size: 14px; color: var(--muted); font-weight: 600; }
    .canvas-wrap { position: relative; height: 46vh; max-height: 520px; min-height: 260px; }
    canvas { width: 100%; height: 100%; display: block; border-radius: 12px; background: #0a0f14; }
    .status { padding: 10px 16px; font-size: 12px; color: var(--muted); }
    footer { padding: 10px 16px; color: var(--muted); font-size: 12px; border-top: 1px solid var(--border); }
    @media (min-width: 1100px) { main { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Mic Waveform · Web</h1>
      <div class="tag">实时波形 / 频谱 · 可调时间窗 · 浏览器端</div>
    </div>
    <div class="spacer"></div>
    <div class="ctrl">
      <label for="win">时间窗</label>
      <select id="win">
        <option value="0.020">20 ms</option>
        <option value="0.050" selected>50 ms</option>
        <option value="0.100">100 ms</option>
        <option value="0.200">200 ms</option>
        <option value="0.500">500 ms</option>
        <option value="1">1 s</option>
        <option value="2">2 s</option>
        <option value="5">5 s</option>
      </select>
      <button id="btn">开始采集</button>
    </div>
  </header>

  <main>
    <section class="card">
      <h2>时间域 · Waveform</h2>
      <div class="canvas-wrap"><canvas id="cWave"></canvas></div>
    </section>
    <section class="card">
      <h2>频率域 · Spectrum</h2>
      <div class="canvas-wrap"><canvas id="cSpec"></canvas></div>
    </section>
  </main>

  <div class="status" id="status">状态：就绪。提示：麦克风需要 HTTPS 或 localhost。</div>
  <footer>
    提醒：首次启动需要点击“开始采集”并允许麦克风权限；如无声，检查系统输入设备是否正确、浏览器是否被静音。
  </footer>

<script>
(() => {
  const el = (id) => document.getElementById(id);
  const $btn = el('btn');
  const $win = el('win');
  const $status = el('status');
  const $cWave = el('cWave');
  const $cSpec = el('cSpec');
  const gw = $cWave.getContext('2d');
  const gs = $cSpec.getContext('2d');
  let running = false;

  // Audio context & graph
  let ac = null;
  let analyser = null; // For spectrum only
  let port = null;     // Worklet port for raw samples
  let sampleRate = 48000;

  // Ring buffer for waveform up to 5s (mono)
  let winSec = parseFloat($win.value);
  let ring = new Float32Array(Math.max(1, Math.floor(winSec * sampleRate)));
  let wptr = 0, filled = false;

  function resizeRing(seconds) {
    winSec = seconds;
    const newN = Math.max(1, Math.floor(winSec * sampleRate));
    const out = new Float32Array(newN);
    // take last newN samples from existing ring
    const current = readAll();
    const slice = current.length > newN ? current.subarray(current.length - newN) : current;
    out.set(slice, newN - slice.length);
    ring = out; wptr = newN; filled = slice.length === newN;
  }

  function writeRing(frame) {
    const n = frame.length;
    if (n >= ring.length) {
      ring.set(frame.subarray(n - ring.length));
      wptr = 0; filled = true; return;
    }
    const end = wptr + n;
    if (end < ring.length) {
      ring.set(frame, wptr); wptr = end;
    } else {
      const p1 = ring.length - wptr;
      ring.set(frame.subarray(0, p1), wptr);
      ring.set(frame.subarray(p1), 0);
      wptr = (end % ring.length); filled = true;
    }
  }

  function readAll() {
    if (!filled) return ring.subarray(0, wptr);
    const idx = new Float32Array(ring.length);
    // reconstruct ordered view
    const out = new Float32Array(ring.length);
    out.set(ring.subarray(wptr));
    out.set(ring.subarray(0, wptr), ring.length - wptr);
    return out;
  }

  // Drawing helpers
  function clear(ctx) {
    const c = ctx.canvas; ctx.clearRect(0, 0, c.width, c.height);
    ctx.fillStyle = '#0a0f14'; ctx.fillRect(0,0,c.width,c.height);
  }
  function drawGrid(ctx, xTicks=8, yTicks=4) {
    const {width:W, height:H} = ctx.canvas;
    ctx.strokeStyle = '#22303c'; ctx.lineWidth = 1;
    ctx.globalAlpha = 0.9; ctx.beginPath();
    for (let i=1;i<xTicks;i++){ const x = (W*i)/xTicks; ctx.moveTo(x,0); ctx.lineTo(x,H);} 
    for (let j=1;j<yTicks;j++){ const y = (H*j)/yTicks; ctx.moveTo(0,y); ctx.lineTo(W,y);} 
    ctx.stroke(); ctx.globalAlpha = 1;
  }
  function drawAxesLabel(ctx, labelL, labelB) {
    ctx.fillStyle = '#8894a3'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(labelL, 10, 16);
    ctx.fillText(labelB, 10, ctx.canvas.height - 8);
  }

  function drawWave() {
    const {width:W, height:H} = gw.canvas;
    clear(gw); drawGrid(gw, 10, 4); drawAxesLabel(gw, 'Amplitude', `Time (last ${winSec.toFixed(3)} s)`);
    const y = readAll(); if (!y.length) return;
    gw.strokeStyle = '#8ab4ff'; gw.lineWidth = 1.5; gw.beginPath();
    const N = y.length; const step = Math.max(1, Math.floor(N / W));
    // downsample with min/max envelope to preserve peaks
    let x = 0; let i = Math.max(0, N - W * step);
    const mid = H * 0.5; const scale = H * 0.45; 
    while (i < N) {
      const j = Math.min(i + step, N);
      let minv = 1e9, maxv = -1e9;
      for (let k=i; k<j; k++){ const v=y[k]; if (v<minv) minv=v; if (v>maxv) maxv=v; }
      const y1 = mid - minv * scale; const y2 = mid - maxv * scale;
      gw.moveTo(x, y1); gw.lineTo(x, y2);
      x += 1; i = j;
    }
    gw.stroke();
  }

  function drawSpec() {
    if (!analyser) return;
    const {width:W, height:H} = gs.canvas;
    clear(gs); drawGrid(gs, 10, 4); drawAxesLabel(gs, 'Magnitude', 'Frequency (Hz)');
    const N = analyser.frequencyBinCount;
    const arr = new Float32Array(N);
    analyser.getFloatFrequencyData(arr); // dB values
    // Normalize to 0..1
    let min = Infinity, max = -Infinity;
    for (let i=0;i<N;i++){ const v=arr[i]; if (v<min) min=v; if (v>max) max=v; }
    const range = (max-min) || 1;
    gs.strokeStyle = '#8ab4ff'; gs.lineWidth = 1.2; gs.beginPath();
    for (let x=0; x<W; x++){
      const idx = Math.floor(x * N / W);
      const v = (arr[idx]-min)/range; // 0..1
      const y = H - v * (H*0.9) - H*0.05;
      if (x===0) gs.moveTo(0,y); else gs.lineTo(x,y);
    }
    gs.stroke();
    // Nyquist label
    gs.fillStyle = '#8894a3'; gs.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
    gs.fillText(`FFT Size: ${analyser.fftSize} · Fs: ${Math.round(sampleRate)} Hz · Nyquist: ${Math.round(sampleRate/2)} Hz`, 10, 16);
  }

  function fitCanvas(c){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = c.getBoundingClientRect();
    const W = Math.max(200, Math.floor(rect.width * dpr));
    const H = Math.max(150, Math.floor(rect.height * dpr));
    if (c.width !== W || c.height !== H){ c.width = W; c.height = H; }
  }

  let rafId = 0;
  function loop(){
    fitCanvas($cWave); fitCanvas($cSpec);
    drawWave(); drawSpec();
    rafId = requestAnimationFrame(loop);
  }

  async function start(){
    if (running) return;
    try {
      $status.textContent = '状态：初始化音频…';
      ac = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = ac.sampleRate || 48000;

      // Create worklet from inline blob (single-file)
      const proc = `class MicTap extends AudioWorkletProcessor {\n  constructor(){ super(); }\n  process(inputs){\n    const ch0 = (inputs[0] && inputs[0][0]) ? inputs[0][0] : null;\n    if (ch0) this.port.postMessage(ch0);\n    return true;\n  }\n}\nregisterProcessor('mic-tap', MicTap);`;
      const blob = new Blob([proc], {type:'application/javascript'});
      const url = URL.createObjectURL(blob);
      await ac.audioWorklet.addModule(url);

      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      const src = ac.createMediaStreamSource(stream);

      // Spectrum
      analyser = ac.createAnalyser();
      analyser.fftSize = 16384; // power of two <= 32768; good compromise
      analyser.smoothingTimeConstant = 0.85;

      // Worklet to capture raw samples for our ring buffer (waveform)
      const tap = new AudioWorkletNode(ac, 'mic-tap');
      port = tap.port; port.onmessage = (ev) => { writeRing(ev.data); };

      // Wire graph: mic -> [analyser, tap] (not to destination)
      src.connect(analyser);
      src.connect(tap);

      // Init ring for selected window
      resizeRing(parseFloat($win.value));

      // UI
      running = true; $btn.textContent = '停止'; $status.textContent = `状态：运行中 · 采样率 ${Math.round(sampleRate)} Hz`;
      loop();
    } catch (err) {
      console.error(err);
      $status.textContent = '错误：' + (err && err.message ? err.message : err);
      running = false; cancelAnimationFrame(rafId);
    }
  }

  function stop(){
    running = false; cancelAnimationFrame(rafId);
    if (ac) { ac.close().catch(()=>{}); ac = null; }
    analyser = null; port = null;
    $btn.textContent = '开始采集';
    $status.textContent = '状态：已停止。';
  }

  $btn.addEventListener('click', () => running ? stop() : start());
  $win.addEventListener('change', () => {
    const s = parseFloat($win.value || '0.05');
    resizeRing(s);
  });

  // Resize handling
  const ro = new ResizeObserver(() => { if (running) { fitCanvas($cWave); fitCanvas($cSpec); } });
  ro.observe($cWave); ro.observe($cSpec);
})();
</script>
</body>
</html>
